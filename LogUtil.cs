using System;
using System.Diagnostics;

using Dalamud.Game;
using Dalamud.Logging;

namespace XIVComboVX {
	internal class LogUtil: IDisposable {
		public const string STACK_TRACE_MSG = "autogenerated stack trace exception";
		private bool disposed;

		public bool Enabled { get; protected set; } = false;
		public bool EnabledNextTick { get; protected set; } = false;

		internal LogUtil() {
			Service.Framework.Update += this.onTick;
		}

		public void EnableNextTick() => this.EnabledNextTick = true;

		internal void fatal(string msg, Exception? cause = null) {
			if (this.Enabled)
				PluginLog.Fatal(cause ?? new Exception(STACK_TRACE_MSG), msg);
		}
		internal void error(string msg, Exception? cause = null) {
			if (this.Enabled)
				PluginLog.Error(cause ?? new Exception(STACK_TRACE_MSG), msg);
		}
		internal void warning(string msg, Exception? cause = null) {
			if (this.Enabled)
				PluginLog.Warning(cause ?? new Exception(STACK_TRACE_MSG), msg);
		}
		[Conditional("DEBUG")]
		internal void debug(string msg) {
			if (this.Enabled)
				PluginLog.Information(msg);
		}
		[Conditional("DEBUG")]
		internal void trace(string msg) {
			if (this.Enabled)
				PluginLog.Debug(
#if TRACE
					new Exception(STACK_TRACE_MSG),
#endif
					msg
				);
		}

		private void onTick(Framework framework) {
			this.Enabled = this.EnabledNextTick;
			this.EnabledNextTick = false;
		}

		#region IDisposable

		protected virtual void Dispose(bool disposing) {
			if (this.disposed)
				return;

			if (disposing) {
				Service.Framework.Update -= this.onTick;
			}

			this.disposed = true;
		}

		public void Dispose() {
			this.Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		#endregion

	}
}
